(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{"+wYG":function(n,e,o){"use strict";o.r(e);var a=o("qNsG"),t=o("q1tI"),s=o.n(t),p=o("6qfE"),r=s.a.createElement;e.default=function(n){var e=n.components;Object(a.a)(n,["components"]);return r(p.MDXTag,{name:"wrapper",components:e},r(p.MDXTag,{name:"h1",components:e},"Decisions about the internal representation"),r(p.MDXTag,{name:"ol",components:e},r(p.MDXTag,{name:"li",components:e,parentName:"ol"},"For data, should there be a single tree with both versions and values, or a separate versions tree?")),r(p.MDXTag,{name:"p",components:e},"If versions are very fragmented, it makes sense to have a single tree. If not, we might save by using separate trees. Versions for queries will likely not be very fragmented but those for data might be."),r(p.MDXTag,{name:"p",components:e},"Decision: Single tree."),r(p.MDXTag,{name:"ol",components:e,props:{start:2}},r(p.MDXTag,{name:"li",components:e,parentName:"ol"},"For queries, should it be possible to specify different versions for different parts?")),r(p.MDXTag,{name:"p",components:e},"Decision: Yes; Without this, query addition will be very limited."),r(p.MDXTag,{name:"ol",components:e,props:{start:3}},r(p.MDXTag,{name:"li",components:e,parentName:"ol"},"For data, should there be node objects for intermediate levels, or some flat structure of key:value pairs (perhaps stored as a prefix tree for space efficiency)?")),r(p.MDXTag,{name:"p",components:e},"Decision: Nodes should be objects; otherwise, evaluating counted ranges become very complicated. (It is required to count distinct keys at a level in the node hierarcy.)"),r(p.MDXTag,{name:"ol",components:e,props:{start:4}},r(p.MDXTag,{name:"li",components:e,parentName:"ol"},"Should query subtraction be supported?")),r(p.MDXTag,{name:"p",components:e},"Preferably, but this is not a hard requirement."),r(p.MDXTag,{name:"ol",components:e,props:{start:5}},r(p.MDXTag,{name:"li",components:e,parentName:"ol"},'Should there be "version" for branch nodes to optimize searches?')),r(p.MDXTag,{name:"p",components:e},"No. Because of links, this will be misleading anyway.\nUpdate: Yes for Query branches, to avoid jumping through obsolete links."),r(p.MDXTag,{name:"ol",components:e,props:{start:6}},r(p.MDXTag,{name:"li",components:e,parentName:"ol"},"Should branch nodes be flattened?")),r(p.MDXTag,{name:"p",components:e},"No, for consistency."),r(p.MDXTag,{name:"h1",components:e},"Rejected options"),r(p.MDXTag,{name:"p",components:e},"// Option 1, flat nodes\n// May be simpler to implement and more efficient if version numbers are very fragmented."),r(p.MDXTag,{name:"p",components:e},"[\nundefined,\nundefined, // Up to key_1 is unknown"),r(p.MDXTag,{name:"p",components:e},"key_1,\nversion_null,\nnull,"),r(p.MDXTag,{name:"p",components:e},"key_2,\nversion_value,\nvalue_2,"),r(p.MDXTag,{name:"p",components:e},"key_2 + \0, // key_2\nversion_null,\nnull,"),r(p.MDXTag,{name:"p",components:e},"key_3,\nversion_null, // key_2 to key_4 is null, but version changes at key_3\nnull,"),r(p.MDXTag,{name:"p",components:e},"key_4,\nundefined, // From key_4 to key_5 we are explicitly setting undefined.\nundefined,"),r(p.MDXTag,{name:"p",components:e},"key_5,\nversion_null,\nnull,"),r(p.MDXTag,{name:"p",components:e},"key_6\nundefined,\nundefined // From last key to end is unknown.\n]"),r(p.MDXTag,{name:"p",components:e},"Record:"),r(p.MDXTag,{name:"p",components:e},"{\n",r(p.MDXTag,{name:"strong",components:e,parentName:"p"},"versions"),": {\nkey_1: version_1,\nkey_2: version_2\n}\nkey_1: value_1,\nkey_2: null\n}"),r(p.MDXTag,{name:"p",components:e},"Query:"),r(p.MDXTag,{name:"p",components:e},"{"),r(p.MDXTag,{name:"p",components:e},"}"),r(p.MDXTag,{name:"p",components:e},"[\n{ key: 'key_1', children: ","[ ... ]"," },\n{ key: 'key_2', }\n]"),r(p.MDXTag,{name:"p",components:e},"Query:"),r(p.MDXTag,{name:"p",components:e},"{\npostsByTime: ","[{ after: '123', first: 10, query: {\ntitle: 1,\nsubtitle: 1,\ntimestamp: 1,\nauthor: {\nname: 1,\navatar: 1\n}\n}}]","\n}"),r(p.MDXTag,{name:"p",components:e},"Graph:"),r(p.MDXTag,{name:"p",components:e},"{\nvalues: {\nposts: {\n22: {\ntitle: 'adsf'\n}\n}"),r(p.MDXTag,{name:"pre",components:e},r(p.MDXTag,{name:"code",components:e,parentName:"pre",props:{metaString:null}},"postsByTime: [\n  undefined,\n  '123',\n  { __ref__: ['posts', '22'] },\n  '123\0',\n  undefined\n]\n")),r(p.MDXTag,{name:"p",components:e},"}"),r(p.MDXTag,{name:"p",components:e},"version: {\nposts: {\n22: 2837\n},\npostsByTime: ["),r(p.MDXTag,{name:"pre",components:e},r(p.MDXTag,{name:"code",components:e,parentName:"pre",props:{metaString:null}},"]\n")),r(p.MDXTag,{name:"p",components:e},"}\n}"),r(p.MDXTag,{name:"p",components:e},"gql`{"),r(p.MDXTag,{name:"p",components:e},"postsByTime(after: 123, first: 10) {\ntitle\nsubtitle\ntimestamp\nauthor {\nname\navatar\n}\n}\n}`;"),r(p.MDXTag,{name:"p",components:e},"query({\ncurrentUser: alias(''),\nfirstPosts: [\n'posts',\n{ first: 10, after: ","['234']"," },\n{\ntitle: 1,\nsubtitle: 1,\ntimestamp: 1,\nauthor: {\nname: 1,\navatar: 1\n}\n}\n]\n}, 3)"),r(p.MDXTag,{name:"p",components:e},"['postsByTime', r.first(10).after('234'), [\n'title',\n'subtitle',\n'timestamp',\n['author', ","[\n'name',\n'avatar'\n]","]\n]]"),r(p.MDXTag,{name:"p",components:e},"// Discarded options."),r(p.MDXTag,{name:"p",components:e},"leaf := {}\nrecord := { }\ncollection := ","[\nvalue, ( key, value )*\n]"),r(p.MDXTag,{name:"p",components:e},"Node {\ndata: ","[ val, ( key, val ) ]","\nvers: ","[ ver, ( key, ver ) ]","\n}"),r(p.MDXTag,{name:"p",components:e},"Trie option:"),r(p.MDXTag,{name:"p",components:e},'Graph:\n{\n"f": { "o": { "o": 42 } },\n"b": { "a": { "r": 1, "z": 2 } }\n}'),r(p.MDXTag,{name:"p",components:e},"Query:\n[ 'postsByTime', { after: '123', first: 10 }, [\n'title',\n'subtitle',\n'timestamp',\n[ 'author', ","[\n'name',\n'avatar'\n]"," ]\n] ]"))}},G2Su:function(n,e,o){(window.__NEXT_P=window.__NEXT_P||[]).push(["/decisions/internal-representation",function(){return o("+wYG")}])}},[["G2Su",1,0]]]);