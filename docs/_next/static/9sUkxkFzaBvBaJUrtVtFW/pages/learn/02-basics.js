(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{"M+6G":function(e,n,a){"use strict";a.r(n);var t=a("qNsG"),o=a("q1tI"),s=a.n(o),r=a("6qfE"),m=s.a.createElement;n.default=function(e){var n=e.components;Object(t.a)(e,["components"]);return m(r.MDXTag,{name:"wrapper",components:n},m(r.MDXTag,{name:"h1",components:n},"Basic usage"),m(r.MDXTag,{name:"p",components:n},"Graffy uses just a few simple yet powerful concepts:"),m(r.MDXTag,{name:"h3",components:n},"Data model"),m(r.MDXTag,{name:"p",components:n},"All the data in your backend is ",m(r.MDXTag,{name:"em",components:n,parentName:"p"},"modeled")," like a single giant JSON tree. In addition to normal JSON values like strings and numbers, leaf nodes in Graffy may contain ",m(r.MDXTag,{name:"strong",components:n,parentName:"p"},"links")," to other parts of the tree. These work just like symlinks in a file system. If you've used Falcor, all this should sound pretty familiar - it's JSON Graph."),m(r.MDXTag,{name:"p",components:n},"Here's an example JSON graph for a toy blog with some ",m(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"users")," and some ",m(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"posts"),":"),m(r.MDXTag,{name:"pre",components:n},m(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"{\n  users: {\n    1: { name: 'Alice', avatar: '\ud83d\udc67', \u2026 },\n    2: { name: 'Bob', avatar: '\ud83d\udc68', \u2026 },\n    \u2026\n  },\n  posts: {\n    1: { author: link('/users/2'), \u2026 },\n    2: { author: link('/users/1'), \u2026 },\n    \u2026\n  }\n}\n")),m(r.MDXTag,{name:"p",components:n},"The ",m(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"author")," property on each post is a link to the corresponding user. ",m(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"link()")," is a helper that creates a link object."),m(r.MDXTag,{name:"blockquote",components:n},m(r.MDXTag,{name:"p",components:n,parentName:"blockquote"},m(r.MDXTag,{name:"strong",components:n,parentName:"p"},"Note"),": The Graffy data model isn't exactly JSON. Keys (property names) don't have to be strings, they can be any data type. Arrays come with many caveats and generally can't be used except as leaf nodes. (This is why ",m(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"users")," and ",m(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"posts")," are objects, not arrays.) ",m(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"null")," has special meaning (a value known to not exist) and can't be used to represent anything else.")),m(r.MDXTag,{name:"h3",components:n},"Queries"),m(r.MDXTag,{name:"p",components:n},"Graffy queries specify all the nodes (down to leaf nodes) they want to fetch, in a tree that mirrors the expected result. This works just like GraphQL:"),m(r.MDXTag,{name:"pre",components:n},m(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"// Query\nstore.fetch({ posts: { 1: { author: { name: true, avatar: true } } } });\n\n// Result\n{ posts: { 1: { author: { name: 'Bob', avatar: '\ud83d\udc68' } } } }\n")),m(r.MDXTag,{name:"p",components:n},"You might have noticed that the query went right through a symlink. This allows Graffy to return multiple nested resources in a single query."),m(r.MDXTag,{name:"h3",components:n},"API"),m(r.MDXTag,{name:"p",components:n},"The API is fairly straightforward and familiar."),m(r.MDXTag,{name:"p",components:n},"Graffy is highly modular, and uses plugins and middleware like Express or Koa Node.js frameworks. Clients typically use graffy-cache to provide in-memory caching and graffy-client, while servers would swap out graffy-client for graffy-server. Setting up a store is straightforward:"),m(r.MDXTag,{name:"pre",components:n},m(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"import Graffy from '@graffy/core';\nimport GraffyCache from '@graffy/cache';\nimport GraffyClient from '@graffy/client';\n\nconst store = new Graffy();\nstore.use(GraffyCache());\nstore.use(GraffyClient('https://example.com/api'));\n")),m(r.MDXTag,{name:"h4",components:n},'"Outer" APIs'),m(r.MDXTag,{name:"ul",components:n},m(r.MDXTag,{name:"li",components:n,parentName:"ul"},m(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"store.fetch(query)")," for one-time queries"),m(r.MDXTag,{name:"li",components:n,parentName:"ul"},m(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"store.watch(query)")," for live queries"),m(r.MDXTag,{name:"li",components:n,parentName:"ul"},m(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"store.patch(graph)")," for writes")),m(r.MDXTag,{name:"p",components:n},"Fetch and patch return promises, while watch returns async iterables."),m(r.MDXTag,{name:"pre",components:n},m(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"const result = await store.fetch(query);\n\nawait store.patch(changes); // Wait till complete.\n\nfor await (const result of store.watch(query)) {\n  /* Each iteration has an updated value of result. */\n}\n")),m(r.MDXTag,{name:"h4",components:n},'"Inner" APIs'),m(r.MDXTag,{name:"ul",components:n},m(r.MDXTag,{name:"li",components:n,parentName:"ul"},m(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"store.onFetch(path, handler)")),m(r.MDXTag,{name:"li",components:n,parentName:"ul"},m(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"store.onWatch(path, handler)")),m(r.MDXTag,{name:"li",components:n,parentName:"ul"},m(r.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"store.onPatch(path, handler)"))),m(r.MDXTag,{name:"p",components:n},"These handlers connect the store to your custom backend databases. Naturally, onFetch and onPatch handlers should return promises and onWatch handlers should return async iterables."),m(r.MDXTag,{name:"pre",components:n},m(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"store.onFetch('/users', query => {\n  const ids = Object.keys(query);\n  return db.collection('users').findAll(ids);\n});\n\nstore.onWatch('/posts', query => {\n  const ids = Object.keys(query);\n\n  // makeAsyncIterable is a helper\n  return makeAsyncIterable(push => {\n    const stream = bus.on('posts', post => {\n      if (ids.includes(post.id)) push(post);\n    });\n    return () => stream.close();\n  });\n});\n")),m(r.MDXTag,{name:"p",components:n},"The store has two more backend APIs, ",m(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"on()")," and ",m(r.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"use()"),". These will be covered in more detail later."),m(r.MDXTag,{name:"h3",components:n},"Next"),m(r.MDXTag,{name:"p",components:n},"Pagination: Ordering and filtering data in queries, constructing indexes."))}},"P+AB":function(e,n,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/learn/02-basics",function(){return a("M+6G")}])}},[["P+AB",1,0]]]);