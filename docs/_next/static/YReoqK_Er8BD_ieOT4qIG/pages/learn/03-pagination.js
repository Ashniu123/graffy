(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{g3rt:function(e,n,a){"use strict";a.r(n);var t=a("qNsG"),o=a("q1tI"),s=a.n(o),p=a("6qfE"),r=s.a.createElement;n.default=function(e){var n=e.components;Object(t.a)(e,["components"]);return r(p.MDXTag,{name:"wrapper",components:n},r(p.MDXTag,{name:"h1",components:n},"Pagination"),r(p.MDXTag,{name:"p",components:n},"Let's take a look at our blog example again."),r(p.MDXTag,{name:"pre",components:n},r(p.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"{\n  posts: {\n    1: { title: 'Introduction', \u2026 },\n    2: { title: 'Basics', \u2026 },\n    \u2026\n  }\n}\n")),r(p.MDXTag,{name:"p",components:n},"It's straightforward to get a post when you know its ID, but that's pretty limiting. More realistically, we might want to fetch, say, 10 posts at a time. We can specify that in the query using an array."),r(p.MDXTag,{name:"h3",components:n},"Slices"),r(p.MDXTag,{name:"pre",components:n},r(p.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"graffy.fetch({\n  posts: [\n    { first: 10 },\n    {\n      title: true,\n      author: { name: true, avatar: true },\n      date: true,\n    },\n  ],\n});\n")),r(p.MDXTag,{name:"p",components:n},"See the ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"{ first: 10 }"),"? That tells Graffy which children of ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"posts")," to include in the response. The second argument (",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"{ title, ... }"),") is the sub-query to apply to each post (i.e. each grandchild of the ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"posts")," node)."),r(p.MDXTag,{name:"p",components:n},"If you're used the GraphQL, you can probably guess how slice works. The first argument to ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"slice()")," can be:"),r(p.MDXTag,{name:"ul",components:n},r(p.MDXTag,{name:"li",components:n,parentName:"ul"},r(p.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"{ first: N }")," or ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"{ last: N }")," for the very first or last N children"),r(p.MDXTag,{name:"li",components:n,parentName:"ul"},r(p.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"{ first: N, after: key }"),", ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"{ last: N, before: key }")," for N children starting at the given key (post ID in this example)"),r(p.MDXTag,{name:"li",components:n,parentName:"ul"},r(p.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"{ after: firstKey, before: lastKey }")," for all the children between the two keys; this could also have a ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"first")," or ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"li"},"last")," property to limit the result.")),r(p.MDXTag,{name:"p",components:n},"Slices by themselves have a pretty serious limitation: they operate on keys, not on values. In this example, we got the first 10 posts ordered by ",r(p.MDXTag,{name:"em",components:n,parentName:"p"},"post ID"),". This isn't super useful."),r(p.MDXTag,{name:"p",components:n},"More realistically, we might want the first 10 posts in January, ordered by date. That can't be accomplished by ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"slice()")," alone, you need an ",r(p.MDXTag,{name:"em",components:n,parentName:"p"},"index"),"."),r(p.MDXTag,{name:"h3",components:n},"Indexes"),r(p.MDXTag,{name:"p",components:n},"Indexes are a common Graffy pattern that uses links and slices to help queries order, filter and paginate over data in different ways."),r(p.MDXTag,{name:"p",components:n},"For example, to query posts based on their date, we might define an index that links dates to the posts:"),r(p.MDXTag,{name:"pre",components:n},r(p.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"// Data\n{\n  posts: {\n    1: { \u2026, date: '2019-03-02' },\n    2: { \u2026, date: '2019-03-04' }\n  },\n  // This is the index\n  postsByDate: {\n    [key('2019-03-02', 1)]: link('/posts/1'),\n    [key('2019-03-04', 2)]: link('/posts/2'),\n  }\n}\n")),r(p.MDXTag,{name:"p",components:n},"Index keys must be unique; as two posts may have the same date, we append the ID to index keys to ensure uniqueness. We also use the ",r(p.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"key()")," helper to specify keys that contain multiple values and types other than strings."),r(p.MDXTag,{name:"blockquote",components:n},r(p.MDXTag,{name:"p",components:n,parentName:"blockquote"},r(p.MDXTag,{name:"strong",components:n,parentName:"p"},"Note"),": The order matters! Keys are sorted by the first value, and subsequent values are only used to break ties.")),r(p.MDXTag,{name:"pre",components:n},r(p.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"// Query: First 10 posts created in January\n{\n  postsByDate: slice(\n    { after: '2019-01-01', before: '2019-01-31', first: 10 },\n    {\n      title: true,\n      author: { name: true, avatar: true },\n      date: true,\n    },\n  );\n}\n")),r(p.MDXTag,{name:"h3",components:n},"Next"),r(p.MDXTag,{name:"p",components:n},"Representing changes."))}},ix6x:function(e,n,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/learn/03-pagination",function(){return a("g3rt")}])}},[["ix6x",1,0]]]);