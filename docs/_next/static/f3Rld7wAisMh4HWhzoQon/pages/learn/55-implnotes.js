(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{"L+gy":function(e,n,a){"use strict";a.r(n);var t=a("qNsG"),o=a("q1tI"),p=a.n(o),i=a("6qfE"),s=p.a.createElement;n.default=function(e){var n=e.components;Object(t.a)(e,["components"]);return s(i.MDXTag,{name:"wrapper",components:n},s(i.MDXTag,{name:"h1",components:n},"Deletion tombstones"),s(i.MDXTag,{name:"p",components:n},"In Graphs, deletions are represented by setting a value to ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"null"),". It's important that these ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"null"),"s are stored and versioned, so that caches can ignore late-arriving updates that happened before the value was deleted, while correctly applying a subsequent update that re-create the deleted value."),s(i.MDXTag,{name:"p",components:n},"The versioned ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"null")," value that's stored in the cache is called a tombstone. The problem is that these tombstones can never be deleted, and might result in bloat and poor performance, especially in applications with a lot of short-lived data."),s(i.MDXTag,{name:"p",components:n},"The solution is for the deletion to not just set the single key to null, but to set the entire range of keys between the neighboring keys (that are still present) to null. For example, imagine a node ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"posts")," with keys ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"a"),", ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"b")," and ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"c"),". The deletion of ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"b")," will not be represented merely by a ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"{ b: null }"),", but by ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"{ <a..c>: null }"),", where ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"<a..c>")," represents the full range of keys between ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"a")," and ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"c")," (excluding them). This range includes b, so this change set will end up deleting ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"b")," from all caches that receive it."),s(i.MDXTag,{name:"p",components:n},"It's important that this change set is specified by only by services that have knowledge that there are no other values between ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"a")," and ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"c"),"."),s(i.MDXTag,{name:"h1",components:n},"Open Slices"),s(i.MDXTag,{name:"p",components:n},"The keys specified in the ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"after")," and ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"before")," parameters are included in the results from a slice. If this is undesirable (e.g. pagination), the ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"nextKey()")," and ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"prevKey()")," helpers can be used. The former appends ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"\0")," to the key, while the latter decrements the key by one bit (a trailing 'b' becomes 'a', for instance) and appends '\xff'."),s(i.MDXTag,{name:"p",components:n},"We take advantage of the limitation that ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"\0")," and ",s(i.MDXTag,{name:"inlineCode",components:n,parentName:"p"},"\xff")," are not valid characters in keys."))}},gVRu:function(e,n,a){(window.__NEXT_P=window.__NEXT_P||[]).push(["/learn/55-implnotes",function(){return a("L+gy")}])}},[["gVRu",1,0]]]);