(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{"6D8z":function(e,n,t){"use strict";t.r(n);var o=t("qNsG"),a=t("q1tI"),s=t.n(a),r=t("6qfE"),i=s.a.createElement;n.default=function(e){var n=e.components;Object(o.a)(e,["components"]);return i(r.MDXTag,{name:"wrapper",components:n},i(r.MDXTag,{name:"h1",components:n},"Graffy Recipies"),i(r.MDXTag,{name:"p",components:n},"These are recommended"),i(r.MDXTag,{name:"h1",components:n},"Fulfilling an index from a relational database"),i(r.MDXTag,{name:"pre",components:n},i(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"store.onFetch('/postsByDate', async query => {\n  const result = { posts: {}, postsByDate: {} };\n  for (const key in query.postsByDate) {\n    const { before, after, first, last } = decode(key);\n    const { id, title, body, author, date } = query.postsByDate[key];\n\n    const rows = await db.query(\n      `SELECT ${[\n        'id',\n        'created_at',\n        title && 'title',\n        body && 'body',\n        author && 'author_id',\n      ]\n        .filter(Boolean)\n        .join(', ')} FROM posts WHERE ${[\n        slice.before && 'date <= $before',\n        slice.after && 'date >= $after',\n      ]\n        .filter(Boolean)\n        .join(' AND ')} ORDER BY date ${last ? 'DESC' : 'ASC'} LIMIT ${last ||\n        first}`,\n      { before, after, count: last || first },\n    );\n\n    rows.forEach(row => {\n      const post = {};\n      if (id) post.id = row.id;\n      if (title) post.title = row.title;\n      if (body) post.body = row.body;\n      if (author) post.author = link(`/users/${row.author_id}`);\n      if (date) post.date = row.created_at;\n      result.posts[row.id] = post;\n      result.postsByDate[key(row.created_at, row.id)] = link(\n        `/posts/${row.id}`,\n      );\n    });\n\n    return result;\n  }\n});\n")))}},Wbhb:function(e,n,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/learn/99-recipes",function(){return t("6D8z")}])}},[["Wbhb",1,0]]]);