<!DOCTYPE html><html><head><meta charset="utf-8"/><link rel="shortcut icon" href="favicon.png"/><link rel="stylesheet" href="index.css"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta name="theme-color" content="#000000"/><title>Graffy</title><meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1"/><meta charSet="utf-8"/><title>Introduction to Graffy</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/YReoqK_Er8BD_ieOT4qIG/pages/learn/01-introduction.js" as="script"/><link rel="preload" href="/_next/static/YReoqK_Er8BD_ieOT4qIG/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-035ac2b14bde147cb4a8.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.1f14ce44d930c2368bf0.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-7362d5fe4a1ff1ce8dc9.js" as="script"/><style id="__jsx-2561753026">body.jsx-2561753026{margin:0;padding:0;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI', 'Roboto','Oxygen','Ubuntu','Cantarell','Fira Sans', 'Droid Sans','Helvetica Neue',sans-serif;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;}code.jsx-2561753026{font-family:source-code-pro,Menlo,Monaco,Consolas, 'Courier New',monospace;}</style></head><body class="jsx-2561753026"><div id="__next"><header class="jsx-2085888330">Graffy</header><div><h1>Introducing Graffy</h1><p>Graffy is a real-time data fetching library for the browser and Node.js. It is still being implemented, and these posts often describe things that don&#x27;t exist (yet). However the PoC is functional enough to introduce the project and get feedback.</p><p>It occupies the same space as the highly popular GraphQL - which I&#x27;ve been working with for about a year - so it&#x27;s important to explain why Graffy exists.</p><h3>Why not GraphQL?</h3><p>GraphQL brings together a large number of good ideas, and Graffy shamelessly borrows many of them. Graffy is also heavily inspired by Falcor, another data fetching library.</p><p>Graffy has several advantages over GraphQL such as improved caching and a simpler data model, but the biggest one - and the reason for starting this project - is support for efficient, scalable <strong>live queries</strong>.</p><p>Live queries are like queries where the server, after returning the initial results, keeps pushing updates to those results as long as the client needs them. These are often the most natural abstractions to use on the client, but GraphQL does not provide an easy way to build them. (No, <a href="https://graphql.org/blog/subscriptions-in-graphql-and-relay/#why-not-live-queries">GraphQL subscriptions are not live queries</a>.)</p><p>GraphQL rejected live queries because they are notoriously hard to implement on the server, especially in a distributed environment. GraphQL subscriptions, which allow server-side events to be pushed pushed more or less directly to the client, are much easier.</p><p>An ideal solution would let server-side code publish change events and client-side code make live queries, with the data fetching library translating between them. This is what Graffy does.</p><p>To do this, Graffy uses data types that provide consistency guarantees and a wire protocol that can efficiently represent diffs, neither of which are available in GraphQL. This is why Graffy has to be a separate library rather than a GraphQL client.</p><h3>Theory of operation</h3><p>Graffy is built on a sound mathematical theory of data and queries. There are two basic types - the Graph, containing data, and the Query, representing <em>data requirements</em>. These types are designed to have operations like addition, subtraction, intersection etc. that behave intuitively - that is, obeying associative, commutative and distributive identities.</p><p>This is the key idea that gives Graffy its advanced capabilities.</p><p>Take, for example, the <em>add</em> and <em>subtract</em> operations on queries. Different components on a page may make separate queries, and Graffy can add them up into a single, de-duplicated query that is sent to the backend. Edge servers can likewise combine queries from multiple clients before hitting backend services.</p><p>Similarly, the <em>merge</em> operation on graphs can be used to combine results from the backend with the cache, or to combine live query change events with known results. The graph data structure is <a href="https://en.wikipedia.org/wiki/Conflict-free_replicated_data_type">conflict-free</a> for the merge operation, so this is resilient to out-of-order updates.</p><p>Other key operations include <em>intersection</em> and <em>difference</em> between a query and a graph. When the graph contains cached data, intersection returns a sub-graph containing only the required data, while difference returns a new query for data that is not present in the cache.</p><h3>Next</h3><p>The basics: How to model, read and write data with Graffy.</p></div></div><script id="__NEXT_DATA__" type="application/json">{"dataManager":"[]","props":{"pageProps":{}},"page":"/learn/01-introduction","query":{},"buildId":"YReoqK_Er8BD_ieOT4qIG","nextExport":true,"autoExport":true}</script><script async="" data-next-page="/learn/01-introduction" src="/_next/static/YReoqK_Er8BD_ieOT4qIG/pages/learn/01-introduction.js"></script><script async="" data-next-page="/_app" src="/_next/static/YReoqK_Er8BD_ieOT4qIG/pages/_app.js"></script><script src="/_next/static/runtime/webpack-035ac2b14bde147cb4a8.js" async=""></script><script src="/_next/static/chunks/commons.1f14ce44d930c2368bf0.js" async=""></script><script src="/_next/static/runtime/main-7362d5fe4a1ff1ce8dc9.js" async=""></script></body></html>