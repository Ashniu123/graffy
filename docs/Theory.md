# Theory of Queries on Graphs

## Data structures

Graffy defines two data structures, Graff and Query, and several operations on them.

### Graffs

**Graffs** are partial views of the application’s data.

Mathematically, they are connected, directed graphs with exactly one “root” node (a node with no incoming edges). Only “leaf” nodes (nodes with no outgoing edges) store values, which may be Null to indicate the absence of a value. All edges have labels, which may be strings or open intervals of lexicographically ordered strings (e.g. [“parrot”…“python”]).

Such a Graph is completely described by its set of leaf nodes, where each leaf node contains a value and a set of paths (sequences of labels) from the root to that leaf. A leaf might have infinitely many paths - graphs are not required to be (and in practice aren’t) acyclic.

Every leaf has one path that is its “canonical” path; this is chosen by the application. All graffs generated by the application that include a leaf must include its canonical path.

### Queries

**Queries** represent data requirements. They are trees and are completely described by the set of paths from the root to each leaf.

### Formal definitions

```
Graff         := { Leaf }
Leaf          := ( CanonicalPath , { LinkedPath } , Value, Clock )
CanonicalPath := [ Key ]
LinkedPath    := [ Key | KeyRange ]

Query         := { QueryPath }
QueryPath     := [ Key | KeyRange | KeyRangeFirst | KeyRangeLast ]

KeyRange      := ( MinKey , MaxKey )
KeyRangeFirst := ( MinKey , MaxKey , Count )
KeyRangeLast  := ( MinKey , MaxKey , Count )
Key           := String
MinKey        := String
MaxKey        := String
Value         := Scalar | Null
Clock         := Non-negative Real
Count         := Non-negative Integer

where { ... } denotes a set, ( ... ) a tuple and [ ... ] a list.
```

## Operations

### Graff union

- **G₁ + G₂ = G₃**

In Graffy, this operation is used to merge changes into the cache and to aggregate results from multiple sources. This operation should be commutative and associative:

- G₁ + G₂ = G₂ + G₁
- G₁ + (G₂ + G₃) = (G₁ + G₂) + G₃

### Query union

- **Q₁ + Q₂ = Q₃**

Aggregate queries from multiple components. This operation should be commutative and associative:

- Q₁ + Q₂ = Q₂ + Q₁
- Q₁ + (Q₂ + Q₃) = (Q₁ + Q₂) + Q₃

### Graff difference

- **G₁ − G₂ = G₃**

When processing a write operation with multiple sinks, compute the pending changes after each partial write. It should be reversible using Graff union:

- (G₁ − G₂) + G₂ = G₁

### Query reduction

- **Q₁ − G = Q₂**

When fulfilling a read operation from multiple sources, compute the pending query after partial read. Also used to compute additional data requirements before notifying a change to each live query.

### Query normalization

- **Q₁ * G = Q₂**

Replace the paths in Q that match a non-canonical path in G with the corresponding canonical paths. This prepares live queries for filtering change graffs, which will always include canonical paths but may not include the non-canonical paths used in the original query.

### Query intersection

- **Q ∩ G₁ = G₂**

Fulfil a query using information in a cache. When a change has been written, computes the parts of that change that are relevant to each pending live query.

This operation should be distributive over Query Union and Graph Union:

- (Q₁ + Q₂) ∩ G = Q₁ ∩ G + Q₂ ∩ G
- Q ∩ ( G₁ + G₂ ) = Q ∩ G₁ + Q ∩ G₂

---

TODO: Write formal definitions of each operation, and proofs that the identities hold.
